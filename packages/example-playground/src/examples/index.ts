// Generated by example-playground/src/utils/watch-examples.ts
// tslint:disable: quotemark

import { runExample as run0 } from './01.stateless-parent-child/compiled';
import { runExample as run1 } from './02.stateful/compiled';
import { runExample as run2 } from './03.thumb/compiled';
import { runExample as run3 } from './04.zoom/compiled';
import { runExample as run4 } from './05.static-gallery/compiled';
import { runExample as run5 } from './06.clock/compiled';
import { runExample as run6 } from './07.reactive.data/compiled';
import { runExample as run7 } from './08.simple.stores/compiled';
import { runExample as run8 } from './09.context/compiled';
import { runExample as run9 } from './10.derived.and.async.stores/compiled';
import { runExample as run10 } from './TODO.animation-sugar/compiled';
import { runExample as run11 } from './TODO.key-matching/compiled';
import { runExample as run12 } from './TODO.Text.Input/compiled';
import { runExample as run13 } from './TODO.type-as-prop/compiled';

export default [{
    name:'01.stateless-parent-child', 
    run: run0,
    source: "// No need to import anything you're not going to use\r\nimport { TSXAir, render } from '../../framework';\r\n\r\n// Components are TSX functions wrapped by TSXAir\r\nexport const ChildComp = TSXAir((props: { name: string }) => <div>Greetings {props.name} from child</div>);\r\nexport const ParentComp = TSXAir((props: { name: string }) => (\r\n    <div>\r\n        Hello {props.name} from parent\r\n        <ChildComp name={props.name} />\r\n    </div>\r\n));\r\n\r\nexport const runExample = (element: HTMLElement) => {\r\n    let count = 1;\r\n    const name = 'Sir Gaga';\r\n    const app = render(element, ParentComp, { name });\r\n\r\n    const i = setInterval(() => {\r\n        app.updateProps({ name: `${name} the ${count++}` });\r\n    }, 50);\r\n    return () => {\r\n        clearInterval(i);\r\n    };\r\n};",
    compiled: "import { Dom } from '../../framework/types/component';\r\nimport { Factory } from '../../framework/types/factory';\r\nimport runtime from '../../framework/runtime';\r\nimport { render } from '../../framework';\r\nimport { Component } from '../../framework/types/component';\r\n\r\ninterface ParentCompProps { name: string; }\r\ninterface ParentCompCtx extends Dom {\r\n    text1: ChildNode;\r\n    childComp1: ChildComp;\r\n}\r\n\r\nexport class ParentComp extends Component<ParentCompCtx, ParentCompProps> {\r\n    public static factory: Factory<ParentComp>;\r\n    public static readonly changeBitmask = {\r\n        name: 1 << 0\r\n    };\r\n\r\n    public $$processUpdate(newProps: ParentCompProps, _: {}, changeMap: number): void {\r\n        if (changeMap & ParentComp.changeBitmask.name) {\r\n            this.context.text1.textContent = newProps.name;\r\n            runtime.updateProps(this.context.childComp1 as ChildComp, (p: ParentCompProps) => {\r\n                p.name = newProps.name;\r\n                return ChildComp.changeBitmask.name;\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nParentComp.factory = {\r\n    unique: Symbol('ParentComp'),\r\n    toString: props => `<div class=\"parent\">\r\n      Hello <!-- start props.name -->${props.name}<!-- end props.name --> from parent\r\n      ${ChildComp.factory.toString(props)}\r\n    </div>`,\r\n    hydrate: (root, props) => new ParentComp(\r\n        {\r\n            root,\r\n            text1: root.childNodes[2],\r\n            childComp1: ChildComp.factory.hydrate(root.children[0] as HTMLElement, props)\r\n        }, props, {}),\r\n    initialState: (_: any) => ({})\r\n};\r\n\r\ninterface ChildCompProps { name: string; }\r\ninterface ChildCompCtx extends Dom { text1: Text; }\r\n\r\n// tslint:disable-next-line: max-classes-per-file\r\nexport class ChildComp extends Component<ChildCompCtx, ChildCompProps> {\r\n    public static factory: Factory<ChildComp>;\r\n    public static readonly changeBitmask = {\r\n        name: 1 << 0\r\n    };\r\n\r\n    public $$processUpdate(newProps: ChildCompProps, _: {}, changeMap: number): void {\r\n        if (changeMap & ChildComp.changeBitmask.name) {\r\n            this.context.text1.textContent = newProps.name;\r\n        }\r\n    }\r\n}\r\n\r\nChildComp.factory = {\r\n    unique: Symbol('ChildComp'),\r\n    toString: (props: { name: string }) => `<div class=\"child\">Greetings <!-- start props.name -->${props.name}<!-- end props.name --> from child</div>`,\r\n    hydrate: (root, props) => new ChildComp({\r\n        root,\r\n        text1: root.childNodes[2] as Text,\r\n    }, props, {}),\r\n    initialState: (_: any) => ({})\r\n};\r\n\r\nexport const runExample = (element: HTMLElement) => {\r\n    let count = 1;\r\n    const name = 'Sir Gaga';\r\n    const app = render(element, ParentComp as any, { name });\r\n\r\n    const i = setInterval(() => {\r\n        app.updateProps({ name: `${name} the ${count++}` });\r\n    }, 50);\r\n    return () => {\r\n        clearInterval(i);\r\n    };\r\n};\r\n\r\n",
    style: ".parent {\r\n    background: rgb(255, 15, 15);\r\n    padding: 1em;\r\n    color: white;\r\n    border-radius: 0.5em;\r\n    box-shadow: 0.1em 0.1em 0.5em 0.5em rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n.child {\r\n    background: rgb(124, 199, 11);\r\n    padding: 0.5em;\r\n    margin:0.5em;\r\n    border-radius: 0.5em;\r\n    box-shadow: 0.1em 0.1em 0.5em 0.5em rgba(0, 0, 0, 0.1);\r\n}",
    readme: "<h1 id=\"statelessparentchildcomponents\">Stateless parent/child components</h1>\n<p>A stateless parent (red) containing a stateless child (green) component</p>\n<h2 id=\"showcases\">Showcases</h2>\n<ul>\n<li>Using imperative component API to update props <em>TBD</em></li>\n<li>Update propagation from parent to child</li>\n</ul>\n<h2 id=\"notes\">Notes</h2>\n<ul>\n<li>The components are defined] declaratively using TSX</li>\n<li>At runtime, the parent updates the child's props using the framework runtime.update (changes are aggregated and applied next frame)</li>\n<li>Props update is <strong>async</strong>, collected by the framework, aggregated and applied next frame</li>\n</ul>"
},
	{
    name:'02.stateful', 
    run: run1,
    source: "import { render, TSXAir, store } from '../../framework';\r\n\r\nexport const StatefulComp = TSXAir((props: { initialState: string }) => {\r\n    const state = store({ a: props.initialState, b: props.initialState, changeCount: 0 });\r\n\r\n    const onClickA = () => state.a = state.a + '!';\r\n    const onClickB = () => state.b = state.b + '*';\r\n\r\n    state.changeCount++;\r\n    /* \r\n    // that's the equivalent of\r\n        when(always, () => state.changeCount++);\r\n    */\r\n\r\n    return <div>\r\n        <div className=\"btn\" onClick={onClickA}>\r\n            {state.a}\r\n        </div>\r\n        <div className=\"btn\" onClick={onClickB}>\r\n            {state.b}\r\n        </div>\r\n        <div>state changed {state.changeCount} times</div>\r\n        {/* \r\n        // The following will fail at compile time\r\n        <div>state changed {state.changeCount++} times</div> \r\n        */}\r\n    </div>;\r\n});\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    render(target, StatefulComp, { initialState: 'Click me!' });\r\n};",
    compiled: "import { Factory } from '../../framework/types/factory';\r\nimport runtime from '../../framework/runtime';\r\nimport { render } from '../../framework';\r\nimport { assignTextContent, noop, handleChanges } from '../../framework/runtime/utils';\r\nimport { Component } from '../../framework/types/component';\r\n\r\n/* tslint:disable:rule no-bitwise */\r\n\r\n// Inferred from the TSX all possible return values \r\ninterface StatefulCompCtx { root: HTMLElement; div1: HTMLDivElement; div2: HTMLDivElement; div3: HTMLDivElement; }\r\n\r\ninterface StatefulCompProps { initialState: string; }\r\n// All the component scope vars [possibly only those who are bound to the view]\r\ninterface StatefulCompState { a: string; b: string; changeCount: number; }\r\n\r\nclass StatefulComp extends Component<StatefulCompCtx, StatefulCompProps, StatefulCompState> {\r\n    public static factory: Factory<StatefulComp>;\r\n    public static readonly changeBitmask = {\r\n        initialState: 1 << 0,\r\n        a: 1 << 1,\r\n        b: 1 << 2,\r\n        changeCount: 1 << 3\r\n    };\r\n\r\n    public $$processUpdate(_: StatefulCompProps, newState: StatefulCompState, changeMap: number): void {\r\n        if (changeMap !== StatefulComp.changeBitmask.changeCount) {\r\n            runtime.updateState(this as StatefulComp, (s: StatefulCompState) => {\r\n                s.changeCount++;\r\n                return StatefulComp.changeBitmask.changeCount;\r\n            });\r\n        }\r\n\r\n        handleChanges(new Map<number, () => void>(\r\n            [\r\n                [StatefulComp.changeBitmask.initialState, noop],\r\n                [StatefulComp.changeBitmask.a, assignTextContent(this.context.div1, newState.a)],\r\n                [StatefulComp.changeBitmask.b, assignTextContent(this.context.div2, newState.b)],\r\n                [StatefulComp.changeBitmask.changeCount, assignTextContent(this.context.div3, `state changed ${newState.changeCount} times`)]\r\n            ]\r\n        ), changeMap);\r\n    }\r\n\r\n    public $afterMount(_: HTMLElement) {\r\n        this.context.div1.addEventListener('click', this.onClickA);\r\n        this.context.div2.addEventListener('click', this.onClickB);\r\n    }\r\n\r\n    private onClickA = () => runtime.updateState(this as StatefulComp, (s: StatefulCompState) => {\r\n        s.a = s.a + '!';\r\n        return StatefulComp.changeBitmask.a;\r\n    });\r\n\r\n    private onClickB = () => runtime.updateState(this as StatefulComp, (s: StatefulCompState) => {\r\n        s.b = s.b + '*';\r\n        return StatefulComp.changeBitmask.b;\r\n    });\r\n}\r\n\r\nconst initialState = (props: StatefulCompProps) => ({ a: props.initialState, b: props.initialState, changeCount: 0 }) as StatefulCompState;\r\nStatefulComp.factory = {\r\n    unique: Symbol('StatefulCompFactory'),\r\n    initialState,\r\n    toString: (props, state?) => {\r\n        state = state || initialState(props);\r\n        return `<div>\r\n        <div class=\"btn\">\r\n            ${state.a}\r\n        </div>\r\n        <div class=\"btn\">\r\n            ${state.b}\r\n        </div>\r\n        <div>\r\n           state changed ${state.changeCount} times \r\n        </div>\r\n    </div>`;\r\n    },\r\n    hydrate: (root, props, state) => new StatefulComp(\r\n        {\r\n            root,\r\n            div1: root.children[0] as HTMLDivElement,\r\n            div2: root.children[1] as HTMLDivElement,\r\n            div3: root.children[2] as HTMLDivElement\r\n        }, props, state || initialState(props)\r\n    )\r\n};\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    render(target, StatefulComp as any, { initialState: 'Click me!' });\r\n};",
    style: ".root>div  {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: flex-start;\r\n}\r\n\r\n.btn {\r\n    user-select: none;\r\n    cursor: pointer;\r\n    border-radius: 0.5em;\r\n    padding: 0.25em;\r\n    margin: 0.25em;\r\n    background: rgb(199, 199, 218);\r\n    transition: all 300ms ease-out;\r\n}\r\n\r\n.btn:hover {\r\n    background: rgb(152, 153, 214);\r\n    transform: scale(1.2);\r\n}",
    readme: "<h1 id=\"statefulcomponent\">Stateful component</h1>\n<p>A component with state (a &amp; b strings) that change upon click</p>\n<h2 id=\"showcases\">Showcases</h2>\n<ul>\n<li>User triggered state update</li>\n</ul>\n<h2 id=\"notes\">Notes</h2>\n<ul>\n<li>The developer simply defines a variable, the <strong>state is inferred</strong> by the compiler</li>\n<li>State update is <strong>async</strong>, collected by the framework, aggregated and applied next frame</li>\n</ul>"
},
	{
    name:'03.thumb', 
    run: run2,
    source: "import { TSXAir, render, store, when } from '../../framework';\r\n\r\nexport const Thumb = TSXAir((props: { url: string, onClick?: (e:MouseEvent) => void }) => {\r\n    const state = store({\r\n        img: new Image(),\r\n        imageLoaded: false\r\n    });\r\n    // runs only once, since img does not change\r\n    state.img.onload = () => {\r\n        state.imageLoaded = true;\r\n    };\r\n\r\n    when(props.url, () => {\r\n        state.img.src = props.url;\r\n        state.imageLoaded = false;\r\n    });\r\n\r\n    // TODO: see if there's a way to make {onClick} valid for props forwarding\r\n    return <div className=\"thumb\" onClick={props.onClick} >\r\n        {state.imageLoaded ? state.img : <div className=\"preloader\" />}\r\n    </div>;\r\n});\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    render(target, Thumb, { url: 'https://i.pinimg.com/originals/ba/ea/e4/baeae441e72112a3154f840b70b930ea.jpg' });\r\n};\r\n",
    compiled: "import { handleChanges } from '../../framework/runtime/utils';\r\nimport runtime from '../../framework/runtime';\r\nimport { Component } from '../../framework/types/component';\r\nimport { Factory } from '../../framework/types/factory';\r\nimport { render } from '../../framework';\r\n\r\n/* tslint:disable:rule no-bitwise */\r\n\r\nexport interface ThumbProps { url: string; onClick?: (e: MouseEvent) => any; }\r\ninterface ThumbState { imageLoaded: boolean; img: HTMLImageElement; }\r\ninterface ThumbCtx { img1?: HTMLImageElement; div1?: HTMLDivElement; root: HTMLDivElement; }\r\n\r\nexport class Thumb extends Component<ThumbCtx, ThumbProps, ThumbState> {\r\n    public static factory: Factory<Thumb>;\r\n    public static readonly changeBitmask = {\r\n        url: 1 << 0,\r\n        onClick: 1 << 1,\r\n        imageLoaded: 1 << 2,\r\n        img: 1 << 3\r\n    };\r\n\r\n    public $$processUpdate(newProps: ThumbProps, newState: ThumbState, changeMap: number): void {\r\n        handleChanges(new Map([\r\n            [Thumb.changeBitmask.url, () => {\r\n                runtime.updateState(this as Thumb, (state: ThumbState) => {\r\n                    // User code\r\n                    state.img.src = newProps.url;\r\n                    state.imageLoaded = false;\r\n                    return Thumb.changeBitmask.imageLoaded;\r\n                });\r\n            }],\r\n            [Thumb.changeBitmask.imageLoaded, () => {\r\n                if (newState.imageLoaded) {\r\n                    this.context.root.innerHTML = '';\r\n                    this.context.root.appendChild(newState.img);\r\n                } else {\r\n                    this.context.root.innerHTML = '<div class=\"preloader\" />';\r\n                }\r\n            }],\r\n            [Thumb.changeBitmask.onClick, () => {\r\n                if (this.props.onClick) {\r\n                    this.context.root.removeEventListener('click', this.props.onClick);\r\n                }\r\n                if (newProps.onClick) {\r\n                    this.context.root.addEventListener('click', newProps.onClick);\r\n                }\r\n            }]\r\n        ]), changeMap);\r\n    }\r\n\r\n    public $afterMount() {\r\n        const { props, state } = this;\r\n        state.img.src = props.url;\r\n        state.img.onload = () => runtime.updateState(this as Thumb, (s: ThumbState) => { s.imageLoaded = true; return Thumb.changeBitmask.imageLoaded; });\r\n        if (this.props.onClick) {\r\n            this.context.root.addEventListener('click', this.props.onClick);\r\n        }\r\n    }\r\n}\r\n\r\nconst initialState = (_props?: ThumbProps) => ({\r\n    imageLoaded: false,\r\n    img: new Image()\r\n}) as ThumbState;\r\n\r\nThumb.factory = {\r\n    unique: Symbol('ThumbFactory'),\r\n    // all derived from the code by the compiler\r\n    initialState,\r\n    toString: (_props, state = initialState()) => `<div class=\"thumb\">\r\n        ${state!.imageLoaded ? `No way to reference the Image as it's created in the instance` : '<div class=\"preloader\"></div>'}\r\n    </div>`,\r\n    hydrate: (target, props, state) => {\r\n        state = state || initialState(props);\r\n        // NOTE: we should also implement validation and error recovery in case of mismatch\r\n        // (not shown here for the sake of simplicity)\r\n        const context: ThumbCtx = {\r\n            root: target as HTMLDivElement,\r\n            // here is where the string generation approach starts to smell funny\r\n            // depending of the state, one of those would have to be created\r\n            img1: state.imageLoaded ? target.children[0] as HTMLImageElement : undefined,\r\n            div1: state.imageLoaded ? undefined : target.childNodes[0] as HTMLDivElement\r\n        };\r\n        return new Thumb(context, props, state);\r\n    }\r\n};\r\n\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    render(target, Thumb as any, { url: 'https://i.pinimg.com/originals/ba/ea/e4/baeae441e72112a3154f840b70b930ea.jpg' });\r\n};\r\n",
    style: ".thumb {\r\n    width: 10em;\r\n    padding: 1em;\r\n    border: blue solid 1px;\r\n}\r\n\r\n.thumb img {\r\n    object-fit: contain;\r\n    max-width: 100%;\r\n    max-height: 100%\r\n}\r\n\r\n.preloader {\r\n    height:10em;\r\n    width:10em;\r\n    background: red;\r\n    border-radius: 50%;\r\n    filter: blur(10px);\r\n}",
    readme: "<h1 id=\"thumbnail\">Thumbnail</h1>\n<h2 id=\"showcases\">Showcases</h2>\n<ul>\n<li>Lifecycle hooks (afterMount &amp; beforeUpdate) used load the image</li>\n<li>Injection of HTMLImageElement created imperatively a declarative the DOM</li>\n<li>Conditional rendering for preloader/image</li>\n</ul>"
},
	{
    name:'04.zoom', 
    run: run3,
    source: "import { TSXAir, render, delegate, store } from '../../framework';\r\nimport { RefHolder } from '../../framework/api/types';\r\nimport { calculateDimensions, Area, calcZoomFrameXY } from './helper';\r\n\r\nexport const Zoom = TSXAir((props: { url: string }) => {\r\n    const state = store({\r\n        zoomedOut: {} as RefHolder<HTMLImageElement>,\r\n        zoomedIn: {} as RefHolder<HTMLImageElement>,\r\n        root: {} as RefHolder<HTMLDivElement>,\r\n        x: 0,\r\n        y: 0,\r\n        original: new Area(),\r\n        zoomFrame: new Area(),\r\n        zoomedOutSize: new Area(1, 1),\r\n    });\r\n\r\n    const updateDimensions = () => {\r\n        [\r\n            state.original,\r\n            state.zoomFrame,\r\n            state.zoomedOutSize\r\n        ] = calculateDimensions(state.root.element!, state.zoomedIn.element!, state.zoomedOut.element!);\r\n    };\r\n\r\n    // Shorthand for afterMount => addEventListener, afterUnmount => removeEventListener\r\n    delegate.window.onresize = updateDimensions;\r\n\r\n    const updateZoomLocation = (e: MouseEvent) => {\r\n        [state.x, state.y] = calcZoomFrameXY(e, state.zoomedOut.element!, state.zoomFrame, state.zoomedOutSize);\r\n    };\r\n\r\n    const {\r\n        zoomedOut,\r\n        zoomedIn,\r\n        root,\r\n        x,\r\n        y,\r\n        original,\r\n        zoomFrame,\r\n        zoomedOutSize\r\n    } = state;\r\n    return <div className=\"zoom\" ref={root} onMouseMove={updateZoomLocation}>\r\n        <div className=\"zoomedIn\">\r\n            <img src={props.url} alt=\"Cute animal, up close\" ref={zoomedIn} onLoad={updateDimensions} />\r\n        </div>\r\n\r\n        <div className=\"zoomedOut\">\r\n            <img src={props.url} alt=\"Cute animal, zoomed out\" ref={zoomedOut}\r\n                style={{\r\n                    left: -x / zoomedOutSize.width * original.width,\r\n                    top: -y / zoomedOutSize.height * original.height\r\n                }} />\r\n            <div className=\"zoomed\" style={{ top: y, left: x, ...zoomFrame }} />\r\n        </div>\r\n    </div >;\r\n});\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    render(target, Zoom, { url: 'https://i.pinimg.com/originals/ba/ea/e4/baeae441e72112a3154f840b70b930ea.jpg' });\r\n};\r\n",
    compiled: "import runtime from '../../framework/runtime';\r\nimport { render } from '../../framework';\r\nimport { Component } from '../../framework/types/component';\r\nimport { Factory } from '../../framework/types/factory';\r\nimport { RefHolder } from '../../framework/api/types';\r\nimport { handleChanges, setStyle } from '../../framework/runtime/utils';\r\nimport { calculateDimensions, calcZoomFrameXY, initialState, Area } from './helper';\r\n\r\n\r\nexport interface ZoomCtx { root: HTMLDivElement; zoomedIn: HTMLImageElement; zoomedOut: HTMLImageElement; zoomFrame: HTMLDivElement; }\r\nexport interface ZoomProps { url: string; }\r\nexport interface ZoomState {\r\n    x: number;\r\n    y: number;\r\n    original: Area;\r\n    zoomFrame: Area;\r\n    zoomedOutSize: Area;\r\n    zoomedOut: RefHolder<HTMLImageElement>;\r\n    zoomedIn: RefHolder<HTMLImageElement>;\r\n    root: RefHolder<HTMLDivElement>;\r\n}\r\n\r\nexport class Zoom extends Component<ZoomCtx, ZoomProps, ZoomState> {\r\n    public static factory: Factory<Zoom>;\r\n    public static readonly changeBitmask = {\r\n        url: 1 << 0,\r\n        x: 1 << 1,\r\n        y: 1 << 2,\r\n        original: 1 << 3,\r\n        zoomFrame: 1 << 4,\r\n        zoomedOutSize: 1 << 5,\r\n        zoomedOut: 1 << 6,\r\n        zoomedIn: 1 << 7,\r\n        root: 1 << 8\r\n    };\r\n\r\n    public $$processUpdate(newProps: ZoomProps, newState: ZoomState, changeMap: number): void {\r\n        handleChanges(new Map([\r\n            [Zoom.changeBitmask.url, () => {\r\n                this.context.zoomedIn.src = this.context.zoomedOut.src = newProps.url;\r\n            }],\r\n            [Zoom.changeBitmask.x | Zoom.changeBitmask.y | Zoom.changeBitmask.zoomedOutSize | Zoom.changeBitmask.original, () => {\r\n                const { x, y, zoomedOutSize, original } = newState;\r\n                setStyle(this.context.zoomedIn, { left: -x / zoomedOutSize.width * original.width, top: -y / zoomedOutSize.height * original.height });\r\n            }],\r\n            [Zoom.changeBitmask.x | Zoom.changeBitmask.y | Zoom.changeBitmask.zoomFrame, () => {\r\n                const { x, y, zoomFrame } = newState;\r\n                setStyle(this.context.zoomFrame, { top: y, left: x, ...zoomFrame });\r\n            }]\r\n\r\n        ]), changeMap);\r\n    }\r\n\r\n    public $afterMount(_ref: HTMLElement) {\r\n        this.context.root.addEventListener('mousemove', e => this.updateZoomLocation(e));\r\n        this.context.zoomedIn.onload = this.updateDimensions;\r\n        window.addEventListener('resize', this.updateDimensions);\r\n    }\r\n\r\n    public $afterUnmount() {\r\n        window.removeEventListener('resize', this.updateDimensions);\r\n    }\r\n\r\n\r\n    private updateDimensions = () => {\r\n        const { root, zoomedIn, zoomedOut } = this.context;\r\n        runtime.updateState(this as Zoom, s => {\r\n            // @ts-ignore\r\n            [s.original, s.zoomFrame, s.zoomedOutSize] = calculateDimensions(root, zoomedIn, zoomedOut);\r\n            return Zoom.changeBitmask.original | Zoom.changeBitmask.zoomFrame | Zoom.changeBitmask.zoomedOutSize;\r\n        });\r\n    };\r\n\r\n    private updateZoomLocation = (e: MouseEvent) => {\r\n        runtime.updateState(this as Zoom, state => {\r\n            // @ts-ignore\r\n            [state.x, state.y] = calcZoomFrameXY(e, state.zoomedOut.element!, state.zoomFrame, state.zoomedOutSize);\r\n            return Zoom.changeBitmask.x | Zoom.changeBitmask.y;\r\n        });\r\n    };\r\n}\r\n\r\nZoom.factory = {\r\n    unique: Symbol('ZoomFactory'),\r\n    toString: (props, state?) => {\r\n        state = state || initialState(props);\r\n        return `<div class=\"zoom\" ref={main}>\r\n            <div class=\"zoomedIn\">\r\n                <img src=\"${props.url}\" alt=\"Cute animal, up close\" ref={zoomedIn} />\r\n            </div>\r\n\r\n            <div class=\"zoomedOut\">\r\n                <img src=\"${props.url}\" alt=\"Cute animal, zoomed out\" />\r\n                <div class=\"zoomed\" />\r\n            </div>\r\n        </div >`;\r\n    },\r\n    hydrate: (root: HTMLElement, props: ZoomProps, state?: ZoomState) => {\r\n        state = state || initialState();\r\n        const context: ZoomCtx = {\r\n            root: root as HTMLDivElement,\r\n            zoomedIn: root.children[0].children[0] as HTMLImageElement,\r\n            zoomedOut: root.children[1].children[0] as HTMLImageElement,\r\n            zoomFrame: root.children[1].children[1] as HTMLDivElement\r\n        };\r\n        state.zoomedIn.element = context.zoomedIn;\r\n        state.zoomedOut.element = context.zoomedOut;\r\n        state.root.element = context.root;\r\n        return new Zoom(context, props, state);\r\n    },\r\n    initialState\r\n} as Factory<Zoom>;\r\n\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    render(target, Zoom as any, { url: '/images/bunny.jpg' });\r\n};",
    style: ".zoom {\r\n    position: relative;\r\n    height: 50vmax;\r\n    width: 50vmax;\r\n}\r\n\r\n.zoomedOut {\r\n    position: absolute;\r\n    width: 30%;\r\n    height: 30%;\r\n    top: 5%;\r\n    left: 5%;\r\n    overflow: visible;\r\n}\r\n\r\n.zoomedOut img {\r\n    object-position: top;\r\n    filter: drop-shadow(0.5em 0.5em 1em);\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: contain;\r\n    cursor: none;\r\n}\r\n\r\n.zoomed {\r\n    border: red solid 2px;\r\n    position: absolute;\r\n    cursor: none;\r\n}\r\n\r\n.zoomedIn {\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n\r\n.zoomedIn img {\r\n    position: absolute;\r\n    object-fit: none;\r\n    object-position: 0;\r\n}",
    readme: "<h1 id=\"imagezoom\">Image Zoom</h1>\n<p>An interactive image zoom</p>\n<h2 id=\"showcases\">Showcases</h2>\n<ul>\n<li>High framerate user interaction</li>\n<li>Component lifecycle</li>\n<li>Access to <em>window</em> (adding resize listener) via <em>optional</em> delegate</li>\n<li>Refs</li>\n</ul>\n<h2 id=\"notes\">Notes</h2>\n<ul>\n<li>The view is updated strictly by state change <em>ref is only used for measurements</em></li>\n<li>To keep the example focused, calculations were moved to a helper module</li>\n<li>The helper is shared by source and compiled code</li>\n<li>To help clarity, names of refs are used in the compiled code</li>\n</ul>"
},
	{
    name:'05.static-gallery', 
    run: run4,
    source: "import { TSXAir, render, store } from '../../framework';\r\nimport { Thumb } from '../03.thumb/source';\r\nimport { Zoom } from '../04.zoom/source';\r\n\r\nexport const Gallery = TSXAir((props: { urls: string[] }) => {\r\n    const state = store({\r\n        zoomed: null as string | null\r\n    });\r\n\r\n    const { zoomed } = state;\r\n\r\n    return <div className=\"gallery\">\r\n        {props.urls.map(url => <Thumb url={url} key={url} onClick={\r\n            // Lambda is all good bro, we're compiling this shit\r\n            () => state.zoomed = url} />)}\r\n        {zoomed ?\r\n            <div className=\"modal\" onClick={\r\n                e => { state.zoomed = null; e.stopPropagation(); }}>\r\n                <Zoom url={zoomed} />\r\n            </div> : null\r\n        }\r\n    </div>;\r\n});\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    const urls = ['https://cdn2.thecatapi.com/images/_mtVKrRTD.jpg', 'https://cdn2.thecatapi.com/images/22CDdXQ6U.jpg',\r\n        'https://cdn2.thecatapi.com/images/qqyh5pKKs.jpg', 'https://cdn2.thecatapi.com/images/bkmLO58jE.jpg',\r\n        'https://cdn2.thecatapi.com/images/KUEJ039io.jpg', 'https://cdn2.thecatapi.com/images/OS1VioBop.jpg',\r\n        'https://cdn2.thecatapi.com/images/vxK9Ac6QU.jpg', 'https://cdn2.thecatapi.com/images/c1vgfDv0b.jpg',\r\n        'https://cdn2.thecatapi.com/images/5A6g4xtZo.jpg', 'https://cdn2.thecatapi.com/images/mt0WK1Pm_.jpg'];\r\n    render(target, Gallery, { urls });\r\n};",
    compiled: "// import { Dom, Component } from '../../framework/types/component';\r\n// import { Factory } from '../../framework/types/factory';\r\n// import runtime from '../../framework/runtime';\r\n// import { Thumb, ThumbProps } from '../03.thumb/compiled';\r\n// import { handleChanges } from '../../framework/runtime/utils';\r\n// import { Zoom, ZoomProps } from '../04.zoom/compiled';\r\n\r\n// // Inferred from the TSX all possible return values \r\n// interface StaticGalleryCtx extends Dom { thumbs: Thumb[]; zoomed: Zoom | null; }\r\n// interface StaticGalleryProps { urls: string[]; onItemClick?: (url: string, index: number) => void; }\r\n// interface StaticGalleryState { zoomed: string | null; }\r\n\r\n// class StaticGallery extends Component<StaticGalleryCtx, StaticGalleryProps, StaticGalleryState> {\r\n//     public static factory: Factory<StaticGallery>;\r\n//     public static readonly changeBitmask = {\r\n//         onItemClick: 1 << 0,\r\n//         urls: 1 << 1,\r\n//         zoomed: 1 << 2\r\n//     };\r\n\r\n\r\n//      zoomedFactory: Factory<Zoom> = {\r\n//         unique: Symbol('ZoomFactoryWrapper'),\r\n//         toString: (props, state = Zoom.factory.initialState(props)) => {\r\n//             return `<div className=\"modal\">\r\n//                 ${ Zoom.factory.toString(props, state)}\r\n//             </div>`;\r\n//         },\r\n//         hydrate: (root: HTMLElement, props, state) => {\r\n//             root.addEventListener('click', this.turnOffZoom);\r\n//             return Zoom.factory.hydrate(root.children[0] as HTMLElement, props, state);\r\n//         },\r\n//         initialState: Zoom.factory.initialState\r\n//     };\r\n\r\n//     private fragments = {\r\n//         zoomed: null\r\n//     };\r\n\r\n//     $$processUpdate(newProps: StaticGalleryProps, newState: StaticGalleryState, changeMap: number): void {\r\n//         handleChanges(new Map([\r\n//             [StaticGallery.changeBitmask.urls, () => {\r\n//                 newProps.urls.forEach((val, i) =>\r\n//                     runtime.updateProps(this.context.thumbs[i] as Thumb, (p: ThumbProps) => {\r\n//                         p.url = val;\r\n//                         return StaticGallery.changeBitmask.urls;\r\n//                     }\r\n//                     ));\r\n//             }],\r\n//             [StaticGallery.changeBitmask.zoomed, () => {\r\n//                 if (newState.zoomed) {\r\n//                     if (this.context.zoomed) {\r\n//                         runtime.updateProps(this.context.zoomed, (p: ZoomProps) => {\r\n//                             p.url = newState.zoomed!;\r\n//                             return Zoom.changeBitmask.url;\r\n//                         }\r\n//                     } else {\r\n//                         this.context.zoomed = \r\n//                     }\r\n//                 } else {\r\n//                     if (this.context.zoomed) {\r\n//                         this.context.zoomed.remove();\r\n//                     }\r\n//                 }\r\n//             }]\r\n//         ]), changeMap);\r\n//     }\r\n\r\n//     $afterMount() {\r\n//         const self = this as StaticGallery;\r\n//         this.context.thumbs.forEach(\r\n//             (thumb, i) => runtime.updateProps(thumb as Thumb, (p: ThumbProps) => {\r\n//                 p.onClick = () => {\r\n//                     // @ts-ignore\r\n//                     runtime.updateState(self as StaticGallery, (s: StaticGalleryState) => {\r\n//                         s.zoomed = thumb.props.url;\r\n//                         return StaticGallery.changeBitmask.zoomed;\r\n//                     });\r\n//                     if (this.props.onItemClick) {\r\n//                         this.props.onItemClick(thumb.props.url, i);\r\n//                     }\r\n//                 };\r\n//                 return Thumb.changeBitmask.onClick;\r\n//             })\r\n//         );\r\n//     }\r\n\r\n\r\n//     private turnOffZoom = () => {\r\n//         runtime.updateState(this as StaticGallery, s => {\r\n//             s.zoomed = null;\r\n//             return StaticGallery.changeBitmask.zoomed;\r\n//         });\r\n//     };\r\n// }\r\n\r\n// const initialState = (_?: any) => ({ zoomed: null }) as StaticGalleryState;\r\n// StaticGallery.factory = {\r\n//     unique: Symbol('StaticGalleryFactory'),\r\n//     toString: (props, state = initialState()) => `<div class=\"gallery\">\r\n//         ${props.urls.map(url => Thumb.factory.toString({ url, key: url })).join('\\n\\t')}\r\n//         ${ state.zoomed ? Zoom.factory.toString({ url: state.zoomed }) : null}\r\n//     </div>`,\r\n//     hydrate: (element, props, state: StaticGalleryState = initialState(props)) => {\r\n//         const children = (Array.from(element.children) as HTMLElement[]);\r\n//         const url = state && state.zoomed || null;\r\n//         let instance: StaticGallery;\r\n//         const hydrateZoomed = initialState.;\r\n//         instance = new StaticGallery({\r\n//             root: element as HTMLDivElement,\r\n//             // TODO: remove or make optional props and state for hydration. the html should be enough\r\n//             thumbs: (url ? children.slice(0, -1) : children).map((thumb, i) => Thumb.factory.hydrate(thumb, { url: props.urls[i] })),\r\n//             zoomed: url ? instance!.hydrateZoomed(children.slice(-1)[0], { url }) : null\r\n//         }, props, state);\r\n//         return instance;\r\n//     },\r\n//     // render: (root, props, state) => {\r\n\r\n//     // },\r\n//     initialState\r\n// } as Factory<StaticGallery>;\r\n\r\n// export const runExample = (_element: HTMLElement) => {\r\n//     runtime.render(element, StaticGallery.factory, {\r\n//         urls: ['https://cdn2.thecatapi.com/images/_mtVKrRTD.jpg', 'https://cdn2.thecatapi.com/images/22CDdXQ6U.jpg',\r\n//             'https://cdn2.thecatapi.com/images/qqyh5pKKs.jpg', 'https://cdn2.thecatapi.com/images/bkmLO58jE.jpg',\r\n//             'https://cdn2.thecatapi.com/images/KUEJ039io.jpg', 'https://cdn2.thecatapi.com/images/OS1VioBop.jpg',\r\n//             'https://cdn2.thecatapi.com/images/vxK9Ac6QU.jpg', 'https://cdn2.thecatapi.com/images/c1vgfDv0b.jpg',\r\n//             'https://cdn2.thecatapi.com/images/5A6g4xtZo.jpg', 'https://cdn2.thecatapi.com/images/mt0WK1Pm_.jpg']\r\n//     });\r\n// };",
    style: ".thumb {\r\n    width: 10em;\r\n    padding: 1em;\r\n    border: blue solid 1px;\r\n}\r\n\r\n.thumb img {\r\n    object-fit: cover;\r\n    width: 100%;\r\n    height: 100%\r\n}\r\n\r\n.preloader {\r\n    height: 10em;\r\n    width: 10em;\r\n    background: red;\r\n    border-radius: 50%;\r\n    filter: blur(10px);\r\n}\r\n\r\n.gallery {\r\n    display: flex;\r\n    flex-direction: row;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n.gallery>* {\r\n    margin: 1em;\r\n}",
    readme: "<h1 id=\"staticgallery\">Static Gallery</h1>\n<p>Uses multiple Thumb to display images, with Zoom modal on click</p>\n<h2 id=\"showcases\">Showcases</h2>\n<ul>\n<li>Component composition</li>\n<li>Declarative collection iteration (urls =&gt; Thumbs)</li>\n<li>Keys &amp; Cats</li>\n<li>Fragments</li>\n</ul>"
},
	{
    name:'06.clock', 
    run: run5,
    source: "import { TSXAir, store, when, requestRender } from '../../framework';\r\n\r\n// exported to keep the example code compact \r\nexport interface AnimatedDiv {\r\n    // _prop will not be spread as attributes\r\n    _isAnimating: boolean;\r\n    // $textContent will be \"spread\" into the element\r\n    $textContent: string;\r\n    className: string;\r\n    key: string;\r\n}\r\n\r\nexport const Digit = TSXAir(async (props: { value: string; lastUpdate: any }) => {\r\n    const current = store({ $textContent: props.value, className: 'enter', _isAnimating: true, key: 'current' } as AnimatedDiv);\r\n    const next = store({ $textContent: '', className: 'waiting', _isAnimating: false, key: 'next' } as AnimatedDiv);\r\n    let pendingValue: string | null = null;\r\n\r\n    const doneAnimating = (elm: AnimatedDiv) => {\r\n        elm._isAnimating = false;\r\n    };\r\n\r\n    when(props.lastUpdate, () => {\r\n        pendingValue = props.value;\r\n    });\r\n\r\n    when([current._isAnimating, next._isAnimating, pendingValue], async () => {\r\n        if ((current._isAnimating || next._isAnimating) === false) {\r\n            current.className = 'no-transition exit';\r\n            next.className = 'no-transition';\r\n            // current.className = 'exit';\r\n            await requestRender();\r\n\r\n            current.className = '';\r\n            next.className = 'waiting';\r\n            current.$textContent = next.$textContent;\r\n            await requestRender();\r\n\r\n            if (pendingValue !== null) {\r\n                next._isAnimating = current._isAnimating = true;\r\n                next.$textContent = pendingValue;\r\n                next.className = '';\r\n                current.className = 'exit';\r\n            }\r\n        }\r\n    });\r\n\r\n    return <div>\r\n        {[current, next].map(div =>\r\n            // It's all good mate, I've compiled it and the key is there, lambdas are also covered in compilation\r\n            // tslint:disable-next-line: jsx-no-lambda jsx-key\r\n            <div {...div} onTransitionEnd={() => doneAnimating(div)} />)}\r\n    </div>;\r\n});",
    compiled: "import { Factory } from './../../framework/types/factory';\r\nimport runtime from '../../framework/runtime';\r\nimport { spreadToElementString, noop, updateSpreadElement, handleChanges } from '../../framework/runtime/utils';\r\n// imported to keep the example code compact \r\nimport { AnimatedDiv } from './source';\r\nimport { Component } from '../../framework/types/component';\r\n\r\n/* tslint:disable:rule no-bitwise */\r\n\r\ninterface DigitContext { root: HTMLElement; divs: HTMLDivElement[]; }\r\ninterface DigitProps { value: string; lastUpdate?: any; }\r\ninterface DigitState {\r\n    current: AnimatedDiv;\r\n    next: AnimatedDiv;\r\n    pendingValue: string | null;\r\n}\r\n\r\nexport class Digit extends Component<DigitContext, DigitProps, DigitState>{\r\n    public static factory: Factory<Digit>;\r\n\r\n    public static readonly propMap = {\r\n        value: 1 << 0,\r\n        lastUpdate: 1 << 1\r\n    };\r\n    public static readonly stateMap = {\r\n        pendingValue: 1 << 2,\r\n        next: {\r\n            _isAnimating: 1 << 3,\r\n            $textContent: 1 << 4,\r\n            className: 1 << 5,\r\n            key: 1 << 6\r\n        },\r\n        current: {\r\n            _isAnimating: 1 << 7,\r\n            $textContent: 1 << 8,\r\n            className: 1 << 9,\r\n            key: 1 << 10\r\n        }\r\n    };\r\n\r\n    public readonly propMap = Digit.propMap;\r\n    public readonly stateMap = Digit.stateMap;\r\n\r\n    private runningAnimateSequence: IterableIterator<void> | null = null;\r\n\r\n    public $$processUpdate(newProps: DigitProps, newState: DigitState, changeMap: number): void {\r\n        const done = new Set();\r\n        const once = (f: () => void) => () => {\r\n            if (!done.has(f)) {\r\n                done.add(f);\r\n                f();\r\n            }\r\n        };\r\n\r\n        const updateCurrent = once(() => {\r\n            updateSpreadElement(this.context.divs[0], newState.current);\r\n        });\r\n\r\n        const updateNext = once(() => {\r\n            updateSpreadElement(this.context.divs[1], newState.next);\r\n        });\r\n\r\n        const animate = once(() => {\r\n            // requestAnimationFrame(() => {\r\n                if (this.runningAnimateSequence) {\r\n                    const res = this.runningAnimateSequence.next(newState);\r\n                    if (res.done) {\r\n                        this.runningAnimateSequence = null;\r\n                    }\r\n                } else {\r\n                    this.runningAnimateSequence = this.whenAnimate(newState);\r\n                    this.runningAnimateSequence.next(newState);\r\n\r\n                }\r\n            // });\r\n        });\r\n\r\n        handleChanges(new Map(\r\n            [\r\n                [Digit.propMap.value, noop],\r\n                [Digit.propMap.lastUpdate, () => runtime.updateState(this as Digit, (s: DigitState) => {\r\n                    if (s.pendingValue !== newProps.value) {\r\n                        s.pendingValue = newProps.value;\r\n                        return Digit.stateMap.pendingValue;\r\n                    }\r\n                    return 0;\r\n                })],\r\n                [Digit.stateMap.next._isAnimating, animate],\r\n                [Digit.stateMap.current._isAnimating, animate],\r\n                [Digit.stateMap.pendingValue, animate],\r\n                [Digit.stateMap.current.className, updateCurrent],\r\n                [Digit.stateMap.current.$textContent, updateNext],\r\n                [Digit.stateMap.next.className, updateNext],\r\n                [Digit.stateMap.next.$textContent, updateNext],\r\n            ]\r\n        ), changeMap);\r\n    }\r\n\r\n    public $afterMount(_ref: any) {\r\n        this.context.divs[0].addEventListener('animationend', this.animationEndedCurrent);\r\n        this.context.divs[0].addEventListener('transitionend', this.animationEndedCurrent);\r\n        this.context.divs[1].addEventListener('transitionend', this.animationEndedNext);\r\n    }\r\n\r\n    private animationEndedCurrent = () => {\r\n        runtime.updateState(this as Digit, (s: DigitState) => {\r\n            s.current._isAnimating = false;\r\n            return Digit.stateMap.current._isAnimating;\r\n        });\r\n    };\r\n\r\n    private animationEndedNext = () => {\r\n        runtime.updateState(this as Digit, (s: DigitState) => {\r\n            s.next._isAnimating = false;\r\n            return Digit.stateMap.next._isAnimating;\r\n        });\r\n    };\r\n\r\n    private *whenAnimate(newState: DigitState): IterableIterator<void> {\r\n        if (newState.current._isAnimating || newState.next._isAnimating) {\r\n            return;\r\n        }\r\n        runtime.updateState(this as Digit, (s: DigitState) => {\r\n            s.current.className = 'no-transition exit';\r\n            s.next.className = 'no-transition';\r\n            return Digit.stateMap.current.className | Digit.stateMap.next.className;\r\n        });\r\n        newState = yield;\r\n        runtime.updateState(this as Digit, (s: DigitState) => {\r\n            s.current.className = '';\r\n            s.next.className = 'waiting';\r\n            s.current.$textContent = s.next.$textContent;\r\n            return Digit.stateMap.current.className | Digit.stateMap.next.className | Digit.stateMap.current.$textContent;\r\n        });\r\n        newState = yield;\r\n        if (newState.pendingValue !== null) {\r\n            runtime.updateState(this as Digit, (s: DigitState) => {\r\n                s.next._isAnimating = s.current._isAnimating = true;\r\n                s.next.$textContent = newState.pendingValue!;\r\n                s.pendingValue = null;\r\n                s.next.className = '';\r\n                s.current.className = 'exit';\r\n                return Digit.stateMap.current.className | Digit.stateMap.pendingValue\r\n                    | Digit.stateMap.next.className | Digit.stateMap.next.$textContent;\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nconst initialState = (props: DigitProps): DigitState => ({\r\n    current: { $textContent: props.value || ' ', className: 'enter', _isAnimating: true, key: 'current' },\r\n    next: { $textContent: ' ', className: 'waiting', _isAnimating: false, key: 'next' },\r\n    pendingValue: null\r\n});\r\n\r\n\r\nDigit.factory = {\r\n    unique: Symbol('DigitFactory'),\r\n    toString: (props: DigitProps, state?: DigitState) => {\r\n        state = state || initialState(props);\r\n        return `<div class=\"digit\">\r\n            ${[state.current, state.next].map(i => spreadToElementString('div', i)).join('')}\r\n        </div>`;\r\n    },\r\n    hydrate: (root: HTMLElement, props: DigitProps, state?: DigitState) =>\r\n        new Digit({\r\n            root,\r\n            divs: root.children as unknown as HTMLDivElement[]\r\n        }, props, state || initialState(props)),\r\n    initialState\r\n} as Factory<Digit>;\r\n\r\nexport const runExample = (target: HTMLElement) => {\r\n    let val = 0;\r\n    const comp = runtime.render(target, Digit.factory, { value: '*' })!;\r\n    const intId = setInterval(() => {\r\n        runtime.updateProps(comp as Digit, (p: DigitProps) => {\r\n            p.lastUpdate = Date.now();\r\n            if (p.value !== '' + val) {\r\n                p.value = '' + val;\r\n                return Digit.propMap.value | Digit.propMap.lastUpdate;\r\n            }\r\n            return Digit.propMap.lastUpdate;\r\n        });\r\n        val++;\r\n        val %= 10;\r\n    }, 1000);\r\n    return () => clearInterval(intId);\r\n};\r\n",
    style: ".digit {\r\n    font-size: 3em;\r\n    width: 0.7em;\r\n    height: 1em;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n\r\n.digit>* {\r\n    font-weight: 900;\r\n    font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;\r\n    transition: transform linear 1000ms;\r\n    transform: translateY(0);\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    transform-origin: center center;\r\n}\r\n\r\n.exit {\r\n    transform:  translateY(-1em);\r\n    /* transition-timing-function: ease-out; */\r\n    transition-delay: 150ms;\r\n    transition-duration: 1000ms;\r\n}\r\n\r\n.enter {\r\n    animation: 500ms enter;\r\n}\r\n\r\n@keyframes enter {\r\n    from {\r\n        transform:  translateY(1em);\r\n    }\r\n    to {\r\n        transform: translateY(0);\r\n    }\r\n}\r\n\r\n.waiting {\r\n    transform: translateY(1em);\r\n}\r\n\r\n.no-transition {\r\n    transition: none;\r\n}",
    readme: "<h1 id=\"clock\">Clock</h1>\n<p>Quick animation of digits using only props and state changes and <strong>no refs</strong> </p>\n<h2 id=\"showcases\">Showcases</h2>\n<ul>\n<li>Element props spreading</li>\n<li>Using _notAProp to make a field be ignored when props spreading</li>\n<li>$textContent special prop</li>\n<li>Deep mutable state</li>\n<li>lifecycle.render()</li>\n</ul>\n<h2 id=\"notes\">Notes</h2>\n<ul>\n<li>This is pretty much impossible in react. The VDom is way too slow, and you have to use refs to circumvent the rendering engine and JSX</li>\n</ul>"
},
	{
    name:'07.reactive.data', 
    run: run6,
    source: "import { TSXAir, store, when } from '../../framework';\r\n\r\nexport const Derived = TSXAir((props:{a:string}) => {\r\n    // The view is updated iff props.a is changed\r\n    return <div>{'a = ' + props.a}</div>;\r\n});\r\n\r\nexport const DerivedWithState = TSXAir((props: { a: string }) => {\r\n    const state = store({ count: 0, first: props.a});\r\n\r\n    console.log(state.count); // nth iteration: n-1\r\n    when(props.a, () => state.count++);\r\n    console.log(state.count); // nth iteration: n, \r\n\r\n    return <div>{'a = ' + props.a}<div>A was changed {state.count} times</div></div>;\r\n});\r\n\r\nexport const DerivedWithCalculations = TSXAir((props: { a: string }) => {\r\n    let calculated;  \r\n    if (props.a === '') {\r\n        calculated = '(No input...)';\r\n    } else {\r\n        calculated = `\"${props.a}\", length: ${props.a.length}`;\r\n    }\r\n\r\n    return <div>{calculated}</div>;\r\n});\r\n\r\nexport const InputValue = TSXAir((_:{})=> {\r\n    const state = store({value:''});\r\n    return <div><input value=\"\" placeholder=\"Say something\"/>{state.value}</div>;\r\n});\r\n\r\nexport const InputValueWithSpread = TSXAir((_:{})=> {\r\n    const state = store({ value: '', placeholder:'Say something'});\r\n    return <div><input {...state} />{state.value}</div>;\r\n});\r\n\r\nexport const ShouldNotCompile1 = TSXAir((_props:{})=>{\r\n    const state = store({ count: 0 });\r\n    return <div>{state.count++}</div>;\r\n});\r\n\r\nexport const ShouldNotCompile2 = TSXAir((_props:{})=>{\r\n    const state = store({ count: 0 });\r\n    return <div>{++state.count}</div>;\r\n});\r\n\r\nexport const ShouldNotCompile3 = TSXAir((props:{a:number})=>{\r\n    let a = props.a + 1;\r\n    // a can only be modified in the render phase, not on events, timeouts etc\r\n    return <div onClick={() => a++}>{a}</div>;\r\n});\r\n\r\nexport const ShouldNotCompile4 = TSXAir((_props: {}) => {\r\n    const state = store({ value: '' });\r\n    // although state.value is a store, it is bound to input.value, and therefor can't be set a value\r\n    return <div><input value=\"\" onChange={() => state.value = state.value + '!'} />{state.value}</div>;\r\n});",
    compiled: "export const runExample = (_: HTMLElement) => {\r\n    return () => null;\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"reactiveviews\">Reactive views</h1>\n<h2 id=\"userguide\">User guide</h2>\n<ul>\n<li>Props, and Stores are not reactive by default</li>\n<li>All other vars and code <strong>are reactive</strong></li>\n<li>A reactive var may <strong>not be set outside the render</strong> cycle (at events, timeouts etc)</li>\n<li>Store changes in the return statement are forbidden</li>\n<li>Assignment to input.value creates a 2-way (reactive) bind</li>\n</ul>\n<h2 id=\"thewhyleadingprincipals\">The why - leading principals</h2>\n<ul>\n<li>From a developer perspective, all the code that can be affected by a change to state/store/prop runs synchronously and sequentially, meaning when change tree branches, should execute as it would if not reactive</li>\n<li>Only affected code should run as a reaction to change</li>\n<li>It should be clear to the developer which parts of the code are reactive and which aren't</li>\n<li>It should be as easy to learn, understand and debug as possible</li>\n</ul>\n<h3 id=\"typesofvariables\">types of variables</h3>\n<h4 id=\"persistentvars\">Persistent vars</h4>\n<ul>\n<li>props defined by the parent component or via component API</li>\n<li>state defined and initiated by the component</li>\n<li>stores can be shared between components</li>\n</ul>\n<p>These are all persistent: they keep the value from previous render cycles and only changed explicitly by the developer. Changing them will trigger a render.</p>\n<p>They are not reactive by default\n(consider making them reactive in case of stores, but it should be explicitly so)</p>\n<h4 id=\"derivedvalues\">Derived values</h4>\n<ul>\n<li><code>const a = props.a</code></li>\n<li><code>const b = props.a + store.a + state.a</code></li>\n</ul>\n<h4 id=\"issueswithambiguousderivedvalues\">Issues with ambiguous derived values</h4>\n<p>Derived values can be ambiguous (for the developer). In order to make learning the system easy, the following cases they will fail at compilation with a clear message:</p>\n<h5 id=\"volatilederivation\">Volatile derivation</h5>\n<p><code>let a = props.a + '1';</code>\nwhat happens when <code>onClick=() =&gt; a = 'a'</code>?\nSince this is ambiguous:</p>\n<ul>\n<li>Set a='a' and make a not be derived from props.a anymore</li>\n<li>Set a='a' and set it to props.a+'1' when props.a changes</li>\n<li>Set a='a', then render, and re-estate the derived value, making the <code>a='a'</code> meaningless with a render side-effect</li>\n</ul>\n<p>Therefore derived values must be defined as const, or have a value definition that is equivalent to one.\nIn any case, changes outside the main render flow, such as event handlers, timeout etc.\nshould fail at compile time</p>\n<h5 id=\"selfreactivevars\">Self reactive vars</h5>\n<pre><code class=\"jsx language-jsx\">const count = initState(0);\nreturn &lt;div&gt;{count++}&lt;/div&gt;;\n</code></pre>\n<p>Can mean</p>\n<ol>\n<li>create or reuse <code>count</code></li>\n<li>render</li>\n<li>add 1 to <code>count</code></li>\n<li>the view does not represent the state, needs render</li>\n<li>rinse, repeat ad infinitum</li>\n</ol>\n<p>Since this is always leads to am infinite loops, it should not be allowed.</p>\n<p>Another interpretation of the same code can be</p>\n<ol>\n<li>create or reuse <code>count</code></li>\n<li>render</li>\n<li>add 1 to <code>count</code></li>\n<li>don't render again</li>\n</ol>\n<p>in which case the behavior is non-reactive (the state change will not be shown until another reactive value changes)</p>\n<h4 id=\"nonselfreactivevars\">Non-self reactive vars</h4>\n<pre><code class=\"jsx language-jsx\">const count = initState(0);\nreturn &lt;div&gt;{++count} - {count}&lt;/div&gt;;\n</code></pre>\n<p>Meaning</p>\n<ol>\n<li>create or reuse <code>count</code></li>\n<li>add 1 to <code>count</code></li>\n<li>render</li>\n</ol>\n<p>While not ambiguous, it does not allow for an async evaluation as it is part of the return statement. It is also very close to the perviously discussed case, making understanding the API more nuanced</p>\n<p>To avoid all of these delicate edge cases, we opt to enforce a simple rule:\n<strong>No state changes allowed in the return statement</strong></p>"
},
	{
    name:'08.simple.stores', 
    run: run7,
    source: "import { TSXAir } from '../../framework';\r\nimport { Store, store } from '../../framework/api/store';\r\n\r\n\r\nexport interface ShopItem {\r\n    label: string;\r\n    img: string;\r\n    code: string;\r\n    price: number;\r\n}\r\n\r\nexport interface CartData {\r\n    [code: string]: number;\r\n}\r\n\r\nconst Item = TSXAir((props: { item: ShopItem, cart: Store<CartData> }) => {\r\n    const { cart, item: { code } } = props;\r\n    cart[code] = cart[code] || 0;\r\n    return <div>\r\n        <div>{props.item.label}</div>\r\n        <div>{props.item.price}</div>\r\n        <img src={props.item.img} alt={props.item.label} />\r\n        <div><input type=\"number\" step={1} min={0} value={cart[code]}/></div>\r\n    </div>;\r\n});\r\n\r\nconst Cart = TSXAir((props: { cart: Store<CartData>, items: Store<ShopItem[]> }) => {\r\n    const purchased = [];\r\n    for (const [code, amount] of Object.entries(props.cart)) {\r\n        if (amount > 0) {\r\n            purchased.push({ item: props.items.find(i => i.code === code)!, amount });\r\n        }\r\n    }\r\n    return <div>\r\n        <ul>\r\n            {purchased.map(({ item, amount }) => <li key={item.code}>{item.label} [{amount}]\r\n            <button onClick={() => props.cart[item.code] = 0}>❌</button>\r\n            </li>)}\r\n        </ul>\r\n        <div>Total: {purchased.reduce((acc, { item, amount }) => acc + item.price * amount, 0)}$</div>\r\n    </div>;\r\n});\r\n\r\n\r\n\r\nconst Catalog = TSXAir((props: { cart: Store<CartData>, items: Store<ShopItem[]> }) => {\r\n    return <div>\r\n        <ul>\r\n            {props.items.map(item => <li key={item.code}>\r\n                <Item item={item} cart={props.cart} />\r\n            </li>)}\r\n        </ul>\r\n    </div>;\r\n});\r\n\r\nexport const Shop = TSXAir((props: { items: ShopItem[] }) => {\r\n    const cart = store({} as CartData);\r\n    const items = store(props.items);\r\n    \r\n\r\n    return <div>\r\n        <Catalog {...{items, cart}} />\r\n        <Cart {...{ items, cart }}/>\r\n    </div>;\r\n    \r\n});",
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"stores\">Stores</h1>\n<p>Stores are a mutule state object. They can be used internally (as state), as a context or a shared state.\nStores are not reactive by default, however any values/views that are derived from them is.</p>"
},
	{
    name:'09.context', 
    run: run8,
    source: "import { TSXAir } from '../../framework';\r\nimport { Store, store } from '../../framework/api/store';\r\nimport { ShopItem, CartData } from '../simple.stores/source';\r\nimport { getContext, setChildrenContext } from '../../framework/api/context';\r\n\r\ninterface ShopContext {\r\n    cart: Store<CartData>;\r\n    items: Store<ShopItem[]>;\r\n}\r\n\r\nconst Item = TSXAir((props: { itemIndex: number }) => {\r\n    const { cart, items } = getContext<ShopContext>();\r\n    const item = items[props.itemIndex];\r\n    cart[item.code] = cart[item.code] || 0;\r\n    return <div>\r\n        <div>{item.label}</div>\r\n        <div>{item.price}</div>\r\n        <img src={item.img} alt={item.label} />\r\n        <div><input type=\"number\" step={1} min={0} value={cart[item.code]} /></div>\r\n    </div>;\r\n});\r\n\r\nconst Cart = TSXAir(() => {\r\n    const { cart, items } = getContext<ShopContext>();\r\n    const purchased = [];\r\n    for (const [code, amount] of Object.entries(cart)) {\r\n        if (amount > 0) {\r\n            purchased.push({ item: items.find(i => i.code === code)!, amount });\r\n        }\r\n    }\r\n    return <div>\r\n        <ul>\r\n            {purchased.map(({ item, amount }) => <li key={item.code}>{item.label} [{amount}]\r\n            <button onClick={() => cart[item.code] = 0}>❌</button>\r\n            </li>)}\r\n        </ul>\r\n        <div>Total: {purchased.reduce((acc, { item, amount }) => acc + item.price * amount, 0)}$</div>\r\n    </div>;\r\n});\r\n\r\n\r\n\r\nconst Catalog = TSXAir(() => {\r\n    const { items } = getContext<ShopContext>();\r\n\r\n    return <div>\r\n        <ul>\r\n            {items.map(({ code }, index) => <li key={code}>\r\n                <Item itemIndex={index} />\r\n            </li>)}\r\n        </ul>\r\n    </div>;\r\n});\r\n\r\nexport const Shop = TSXAir((props: { items: ShopItem[] }) => {\r\n    const cart = store({} as CartData);\r\n    const items = store(props.items);\r\n    setChildrenContext(store({ cart, items }));\r\n\r\n    return <div>\r\n        <Catalog />\r\n        <Cart />\r\n    </div>;\r\n});",
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"context\">Context</h1>\n<p>Context is a shared store that can be accessed by any component down the tree of the component that set it.</p>\n<h2 id=\"api\">API</h2>\n<p>getContext - get the context set by the closest ancestor\nsetChildrenContext - set the context for descendant components -  and be used with store.derived to create a derived/partial context\n with store.derived to create a derived/partial context</p>"
},
	{
    name:'10.derived.and.async.stores', 
    run: run9,
    source: "import { TSXAir, store } from '../../framework';\r\nimport { Shop, ShopItem } from '../simple.stores/source';\r\n\r\nexport const ShopWithApi = TSXAir((props: { api: string }) => {\r\n    /*\r\n        data is a derived store, so it WILL be reactive, that's sugar for:\r\n            const data = fetch(props.api).then(data => data.json());\r\n            when(props.api, () => data = fetch(props.api).then(data => data.json()));\r\n     */\r\n    const data = store.derived(fetch(props.api).then(({ json }) => json() as Promise<ShopItem[]>));\r\n\r\n    /*\r\n        async store and assigns the resolved value onto the store, making the promise resolution reactive\r\n        It adds the AsyncStoreApi to the store: $pending, $rejected, $promise, $resolved (=store iff resolved)\r\n    */\r\n    const items = store.async(store.derived(data));\r\n\r\n    if (items.$pending) {\r\n        return <div className=\"preloader\" />;\r\n    }\r\n\r\n    if (items.$rejected) {\r\n        return <div className=\"error\">{items.$rejected}</div>;\r\n    }\r\n\r\n    return <Shop {...{ items }} />;\r\n});",
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"derivedandasyncstores\">Derived and Async stores</h1>\n<h2 id=\"derivedstores\">Derived stores</h2>\n<p>A reactive store, that will behave like any a simple reactive value: it will be reset iff the data origin changes, and can't be set outside the main render function (i.e events, timeouts etc)</p>\n<h2 id=\"asyncstores\">Async stores</h2>\n<p>Syntactic sugar for async activity, it assigns a promise result onto the store, along with async api:</p>\n<ul>\n<li>$pending - true until the promise is settled</li>\n<li>$rejected - reason in case of rejection</li>\n<li>$resolved - resolved value is case of resolution. this value is also assigned to the store</li>\n<li>$promise - the store origin</li>\n</ul>"
},
	{
    name:'TODO.animation-sugar', 
    run: run10,
    source: '',
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"animationsugar\">Animation Sugar</h1>\n<p>Svelte has very nice enter/leave animation sugar. We should too</p>"
},
	{
    name:'TODO.key-matching', 
    run: run11,
    source: '',
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"keymatching\">Key matching</h1>\n<p>Finding the right child when props and state changes</p>"
},
	{
    name:'TODO.Text.Input', 
    run: run12,
    source: '',
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: ''
},
	{
    name:'TODO.type-as-prop', 
    run: run13,
    source: '',
    compiled: "export const runExample = (_target: HTMLElement) => {\r\n    // TODO\r\n};\r\n",
    style: '',
    readme: "<h1 id=\"typeasprop\">Type as prop</h1>\n<p>Consider creating a website from json data: the created children's types are data derived so a syntax such as <code>&lt;slot type={TypeFroData} /&gt;</code> is require</p>\n<h2 id=\"possibleexamples\">possible examples</h2>\n<ul>\n<li>from builder</li>\n<li>widget builder</li>\n<li>Wix.com</li>\n</ul>"
}] as Example[];

export interface Example {
    run: (target:HTMLElement) => () => void;
    name: string;
    source: string;
    compiled: string;
    style: string;
    readme: string;
}